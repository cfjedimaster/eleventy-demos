---
layout: post
title: "An experiment in combining JavaScript and CSS Requests"
date: "2010-04-26T14:04:00+06:00"
categories: [coldfusion]
tags: []
banner_image: 
permalink: /2010/04/26/An-experiment-in-combining-JavaScript-and-CSS-Requests
guid: 3791
---

During Peter Farrell's cfObjective presentation on front end optimizations, one of the <b>many</b> tips he had involved minimizing the amount of HTTP requests your HTML makes. As a simple, and somewhat contrived example, consider the following HTML:
<!--more-->
<p>
<code>
&lt;html&gt;
&lt;head&gt;
&lt;script src="/jquery/jquery.js"&gt;&lt;/script&gt;
&lt;script src="/jquery/jquery.cookie.js"&gt;&lt;/script&gt;
&lt;script src="/jquery/jquery.flot.js"&gt;&lt;/script&gt;
&lt;script src="/jquery/jquery.validate.js"&gt;&lt;/script&gt;
&lt;script src="/jquery/jquery.selectboxes.js"&gt;&lt;/script&gt;

&lt;script&gt;
$(document).ready(function() {
	$("body").append("&lt;p&gt;Loaded jQuery")
})
&lt;/script&gt;
&lt;link rel="stylesheet" href="/cfdocs/newton_ie.css" type="text/css" /&gt;
&lt;link rel="stylesheet" href="/cfdocs/newton_ns.css" type="text/css" /&gt;
&lt;link rel="stylesheet" href="/cfdocs/toc.css" type="text/css" /&gt;

&lt;/head&gt;
&lt;body&gt;
Hello World.
&lt;/body&gt;
&lt;/html&gt;
</code>
<p>
As you can see, I've got jQuery and 4 plugins being loaded. I've also got 3 different style sheets. All in all this reflects 8 additional HTTP requests the page has to make while parsing the HTML, and that's not counting the images that would normally make up an average web page.
<p>
As a graphical example of the impact of these scripts, check out the YSlow report:
<p>

<img src="https://static.raymondcamden.com/images/Screen shot 2010-04-26 at 12.26.54 PM.png" title="Initial YSlow Report" />

<p>

As you can see, I got a C and an overall score of 70. The first thing YSlow points out to me are the number of HTTP requests. I decided to write my own CFML code to see if I can address this. My code would act as a simple service. I'd pass it a list of files and the code would return all the resources in one request. <b>Before going any further, please note I did this as an experiment.</b> There is a supported, and more full featured, open source project out now you should use instead of my code: <a href="http://combine.riaforge.org">combine</a>. I just wrote this for fun - so please keep that in mind. Ok, with that out of the way, let's go through what I built step by step.

<p>

<code>
&lt;cfsetting enablecfoutputonly="true" showdebugoutput="false"&gt;
</code>

<p>

I begin by enabling cfoutoutput only. This will reduce the whitespace generated by the request. Since I'm serving up JavaScript and CSS files, it also makes sense to disable debug  output.

<p>

<code>
&lt;cfset variables.rootfolder = ["/Library/WebServer/Documents/jquery/", "/Library/WebServer/Documents/cfdocs/"]&gt;
</code>

<p>

Next we have a root folder setting. You <b>must</b> edit this line before using the script. I felt bad about this at first because it felt like it should be something I externalize - but then I remembered - I'm not building a custom tag here. I'm building a service. So one small amount of setup isn't so bad. Why the array? Well, this (and the next block) are the one part I'm most unsure of. For security reasons, I didn't want you to pass in full paths to files. Therefore, it makes sense to embed a root folder in the service itself. However, many people keep their CSS and JS files separate. I could allow folks to simply use their web root for the root but then they would need to pass in the subfolder for every resource requested. Ie, something like /js/foo.js, /js/goo.js, /js/zoo.js. My solution was to allow for <b>either</b> a simple string value or an array. If you use a string, well, it's used as is. If you use an array, I allow you to pass which index to use for the root in the URL string. More on that in a second. If you don't specify one, then the first array element is used.

<p>

<code>
&lt;cfparam name="url.root" default=""&gt;
&lt;!--- Only care about url.root if passed and if variables.rootfolder is an array ---&gt;
&lt;cfif len(url.root) and isArray(variables.rootfolder) and isNumeric(url.root) and 
	  url.root gte 1 and url.root lte arrayLen(variables.rootfolder) and round(url.root) is url.root&gt;
	  &lt;cfset variables.folder = variables.rootfolder[url.root]&gt;
&lt;cfelseif isArray(variables.rootfolder)&gt;
	&lt;cfset variables.folder = variables.rootfolder[1]&gt;
&lt;cfelse&gt;
	&lt;cfset variables.folder = variables.rootfolder&gt;
&lt;/cfif&gt;
</code>

<p>

So yeah, here is the part I really don't like. As I said, you can use an array of root folders, and you can ask for a specific one via the URL. I use url.root for that value. I didn't want you to pass in a string value of course, so instead, I simply let you pass in the index. This requires some knowledge of the configuration. All in all, this feels a bit wonky. You've never had to really hide the paths of resources before, so why bother? If I were to rewrite this, I'd probably suggest folks use the web root and simply use the subfolders when requesting resources. Actually, I don't have to rewrite it - that works already. So um - consider it deprecated. ;) Ok, carrying on....

<p>

<code>
&lt;!--- 
Root Type: This should be .js or .css. 
---&gt;
&lt;cfparam name="url.roottype" default=".js"&gt;

&lt;!--- Set our content type based on roottype ---&gt;
&lt;cfif url.roottype is ".js"&gt;
	&lt;cfset variables.contenttype = "text/javascript"&gt;
&lt;cfelse&gt;
	&lt;!--- I set url.roottype just to be anal since we use it again later for file security ---&gt;
	&lt;cfset url.roottype = ".css"&gt;
	&lt;cfset variables.contenttype = "text/css"&gt;
&lt;/cfif&gt;
</code>

<p>

The next block of code handles setting up a requirement for the <i>type</i> of file being requested. This will allow us to do a security check later on, and it also allows us to use the right content type. I could have simply looked at the first resource requested (is it something.js or something.css), but I felt like being anal about allowed me to really lock it down to *.js or *.css. 

<p>

<code>
&lt;cfparam name="url.list" default=""&gt;

&lt;!--- If blank, quickly leave. ---&gt;
&lt;cfif url.list is ""&gt;
	&lt;cfabort&gt;
&lt;/cfif&gt;
</code>

<p>

Here we define the URL parameter that will contain the requested resources.

<p>

<code>
&lt;cfparam name="url.refreshcache" default="0"&gt;
</code>

<p>

Here is our hook to let us refresh the cache. More on that in a bit.

<p>

<code>
&lt;cfset variables.scope = "application"&gt;
</code>

<p>

The service will use a cache for it's file work. I can't imagine needing a different scope than Application, but if you need to - you can tweak it.

<p>

<code>
&lt;cfset variables.cacheRoot = "_multiloadres2"&gt;
</code>

<p>

And there is the key used for the cache.

<p>

<code>
&lt;cfset cacheScope = structGet(variables.scope)&gt;
&lt;cfset needInit = false&gt;
&lt;cflock scope="#variables.scope#" type="readOnly" timeout="10"&gt;
	&lt;cfif not structKeyExists(cacheScope, variables.cacheRoot)&gt;
		&lt;cfset needInit = true&gt;
	&lt;/cfif&gt;
&lt;/cflock&gt;
&lt;cfif needInit&gt;
	&lt;cflock scope="#variables.scope#" type="exclusive" timeout="10"&gt;
		&lt;cfif not structKeyExists(cacheScope, variables.cacheRoot)&gt;
			&lt;cfset cacheScope[variables.cacheRoot] = {}&gt;
		&lt;/cfif&gt;
	&lt;/cflock&gt;
&lt;/cfif&gt;
</code>

<p>

There we have the cache set up routine. Notice I use structGet (remember it?) to create a pointer to the scope holding my cache. I do the necessary locks and create the root structure for my cache if I need to.

<p>

<code>
&lt;cfif isBoolean(url.refreshcache) and not url.refreshcache&gt;

	&lt;cfif structKeyExists(cacheScope[variables.cacheRoot], url.list)&gt;
		&lt;cfheader name="expires" value="#getHTTPTimeString("1/1/2032")#"&gt;
		&lt;cfcontent type="#variables.contenttype#"&gt;&lt;cfoutput&gt;#cacheScope[variables.cacheRoot][url.list]#&lt;/cfoutput&gt;&lt;cfabort&gt;
	&lt;/cfif&gt;
		
&lt;/cfif&gt;
</code>

<p>

Now that we have a cache, we can actually use it - if it exists in the cache. Notice too the use of the expires header. YSlow pointed this out to me during my development. To my readers in 2032, I apologize. Also, please tell the alien overlords to be nice to my kids.

<p>

<code>
&lt;cfset buffer = ""&gt;
&lt;cfloop index="res" list="#url.list#"&gt;
	&lt;!--- For each file, if it contains .., assume it is a hack attempt and immediately barf. ---&gt;
	&lt;cfif find("..", res)&gt;
		&lt;cfabort&gt;
	&lt;/cfif&gt;
	&lt;!--- For each file, if it does not end in js, assume it is a hack attempt and immediately barf. ---&gt;
	&lt;cfif right(res, len(url.roottype)) is not url.roottype&gt;
		&lt;cfabort&gt;
	&lt;/cfif&gt;
	&lt;cfset trueFile = variables.folder & "/" & res&gt;
	&lt;!--- If the file doesn't exist, we skip. Don't throw an error because we don't want to be used to scan the system. ---&gt;
	&lt;cfif fileExists(trueFile)&gt;
		&lt;cfset buffer &= fileRead(trueFile)&gt;
	&lt;/cfif&gt;
&lt;/cfloop&gt;
</code>

<p>

Woot! Finally some real work. Here you can see how we loop over the list of requested files. For each, I'm going to do a quick extension check, and if it passes, and if the file exists, I read the contents into a buffer variable. That's really it. Pretty simple, right?

<p>

<code>
&lt;cfif len(buffer)&gt;
	&lt;cfset cacheScope[variables.cacheRoot][url.list] = buffer&gt;
	&lt;cfif isBoolean(url.refreshcache) and not url.refreshcache&gt;
		&lt;cfheader name="expires" value="#getHTTPTimeString("1/1/2032")#"&gt;
	&lt;cfelse&gt;
		&lt;cfheader name="expires" value="#getHTTPTimeString(now())#"&gt;	
	&lt;/cfif&gt;
	&lt;cfcontent type="#variables.contenttype#"&gt;&lt;cfoutput&gt;#cacheScope[variables.cacheRoot][url.list]#&lt;/cfoutput&gt;
&lt;/cfif&gt;
</code>

<p>

The final bits then simply handle storing the buffer into the cache and finally returning it to the client. Again, note the user of the expires header. Ok, so how does it look when I use it? Here is a modified form of the original HTML:

<p>

<code>
&lt;html&gt;
&lt;head&gt;
&lt;script src="multiload.cfm?list=jquery.js,jquery.cookie.js,jquery.flot.js,jquery.validate.js,jquery.selectboxes.js"&gt;&lt;/script&gt;
&lt;script&gt;
$(document).ready(function() {
	$("body").append("&lt;p&gt;Loaded jQuery")
})
&lt;/script&gt;
&lt;link rel="stylesheet" href="multiload.cfm?root=2&roottype=.css&list=newton_ie.css,newton_ns.css,toc.css" type="text/css" /&gt;

&lt;/head&gt;
&lt;body&gt;
Hello World.
&lt;/body&gt;
&lt;/html&gt;
</code>

<p>

As you can see, each of my multiple JS and CSS requests have been turned into one. For the CSS one I have to specify a bit more as most of my defaults are for JS. But really, it isn't that difficult to use. And the result?

<p>

<img src="https://static.raymondcamden.com/images/cfjedi/Screen shot 2010-04-26 at 12.46.48 PM.png" title="Second YSlow Report" />


<p>

Woot! An A! Those of you who know how fragile my ego is will not be surprised to hear this made me do a quick little dance of joy. Anyway, it was really fun to build this, but again, I'll point people to the <a href="http://combine.riaforge.org">combine</a> project by Joe Roberts. His also adds compression to the mix for even more performance. The complete code for the script is below. Enjoy.

<p>

<code>
&lt;cfsetting enablecfoutputonly="true" showdebugoutput="false"&gt;
&lt;!---
Root Folder:
This may be a simple path (full path!) or an array. Using an array allows you to use
one instance of this script and N root paths. If an array is used, you specify a specific
root folder by using root=N. It may be confusing to have to specify the array index, but it
also means you aren't passing a real path along the query string. You can also leave it out
for the 1st item in the array.

Note - this is the only line you need to edit (most likely!)
---&gt;
&lt;!---
&lt;cfset variables.rootfolder = "/Library/WebServer/Documents/jquery/"&gt;
---&gt;
&lt;cfset variables.rootfolder = ["/Library/WebServer/Documents/jquery/", "/Library/WebServer/Documents/cfdocs/"]&gt;

&lt;cfparam name="url.root" default=""&gt;
&lt;!--- Only care about url.root if passed and if variables.rootfolder is an array ---&gt;
&lt;cfif len(url.root) and isArray(variables.rootfolder) and isNumeric(url.root) and 
	  url.root gte 1 and url.root lte arrayLen(variables.rootfolder) and round(url.root) is url.root&gt;
	  &lt;cfset variables.folder = variables.rootfolder[url.root]&gt;
&lt;cfelseif isArray(variables.rootfolder)&gt;
	&lt;cfset variables.folder = variables.rootfolder[1]&gt;
&lt;cfelse&gt;
	&lt;cfset variables.folder = variables.rootfolder&gt;
&lt;/cfif&gt;

&lt;!--- 
Root Type: This should be .js or .css. 
---&gt;
&lt;cfparam name="url.roottype" default=".js"&gt;

&lt;!--- Set our content type based on roottype ---&gt;
&lt;cfif url.roottype is ".js"&gt;
	&lt;cfset variables.contenttype = "text/javascript"&gt;
&lt;cfelse&gt;
	&lt;!--- I set url.roottype just to be anal since we use it again later for file security ---&gt;
	&lt;cfset url.roottype = ".css"&gt;
	&lt;cfset variables.contenttype = "text/css"&gt;
&lt;/cfif&gt;

&lt;!---
List of resources to load.
---&gt;
&lt;cfparam name="url.list" default=""&gt;

&lt;!--- If blank, quickly leave. ---&gt;
&lt;cfif url.list is ""&gt;
	&lt;cfabort&gt;
&lt;/cfif&gt;

&lt;!---
If true, we don't use a cached version of the resource.
---&gt;
&lt;cfparam name="url.refreshcache" default="0"&gt;

&lt;!--- 
Default scope for the cache. No reason normally to tweak this.
---&gt;
&lt;cfset variables.scope = "application"&gt;

&lt;!---
Key used to store cached info
---&gt;
&lt;cfset variables.cacheRoot = "_multiloadres2"&gt;

&lt;!--- 
Ok, begin working.
---&gt;

&lt;!--- I handle creating initial cache struct ---&gt;
&lt;cfset cacheScope = structGet(variables.scope)&gt;
&lt;cfset needInit = false&gt;
&lt;cflock scope="#variables.scope#" type="readOnly" timeout="10"&gt;
	&lt;cfif not structKeyExists(cacheScope, variables.cacheRoot)&gt;
		&lt;cfset needInit = true&gt;
	&lt;/cfif&gt;
&lt;/cflock&gt;
&lt;cfif needInit&gt;
	&lt;cflock scope="#variables.scope#" type="exclusive" timeout="10"&gt;
		&lt;cfif not structKeyExists(cacheScope, variables.cacheRoot)&gt;
			&lt;cfset cacheScope[variables.cacheRoot] = {}&gt;
		&lt;/cfif&gt;
	&lt;/cflock&gt;
&lt;/cfif&gt;

&lt;!--- I handle caching concerns ---&gt;
&lt;cfif isBoolean(url.refreshcache) and not url.refreshcache&gt;

	&lt;cfif structKeyExists(cacheScope[variables.cacheRoot], url.list)&gt;
		&lt;cfheader name="expires" value="#getHTTPTimeString("1/1/2032")#"&gt;
		&lt;cfcontent type="#variables.contenttype#"&gt;&lt;cfoutput&gt;#cacheScope[variables.cacheRoot][url.list]#&lt;/cfoutput&gt;&lt;cfabort&gt;
	&lt;/cfif&gt;
		
&lt;/cfif&gt;

&lt;!--- I handle loading my files ---&gt;
&lt;cfset buffer = ""&gt;
&lt;cfloop index="res" list="#url.list#"&gt;
	&lt;!--- For each file, if it contains .., assume it is a hack attempt and immediately barf. ---&gt;
	&lt;cfif find("..", res)&gt;
		&lt;cfabort&gt;
	&lt;/cfif&gt;
	&lt;!--- For each file, if it does not end in js, assume it is a hack attempt and immediately barf. ---&gt;
	&lt;cfif right(res, len(url.roottype)) is not url.roottype&gt;
		&lt;cfabort&gt;
	&lt;/cfif&gt;
	&lt;cfset trueFile = variables.folder & "/" & res&gt;
	&lt;!--- If the file doesn't exist, we skip. Don't throw an error because we don't want to be used to scan the system. ---&gt;
	&lt;cfif fileExists(trueFile)&gt;
		&lt;cfset buffer &= fileRead(trueFile)&gt;
	&lt;/cfif&gt;
&lt;/cfloop&gt;

&lt;!--- All done - if we actually have content, cache it and store it. ---&gt;
&lt;cfif len(buffer)&gt;
	&lt;cfset cacheScope[variables.cacheRoot][url.list] = buffer&gt;
	&lt;cfif isBoolean(url.refreshcache) and not url.refreshcache&gt;
		&lt;cfheader name="expires" value="#getHTTPTimeString("1/1/2032")#"&gt;
	&lt;cfelse&gt;
		&lt;cfheader name="expires" value="#getHTTPTimeString(now())#"&gt;	
	&lt;/cfif&gt;
	&lt;cfcontent type="#variables.contenttype#"&gt;&lt;cfoutput&gt;#cacheScope[variables.cacheRoot][url.list]#&lt;/cfoutput&gt;
&lt;/cfif&gt;
</code>